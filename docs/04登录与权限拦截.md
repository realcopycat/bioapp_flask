## 登录与权限拦截

> https://github.com/vimalloc/flask-jwt-extended

关于权限校验，采用 jwt + cookie + 自定义装饰实现。在 web 端中使用 cookie 实现，后期拓展其他端时直接使用 jwt token 即可。



### 插件初始化

```python
# -*- coding: utf-8 -*-
# filename: pear_admin/extensions.py
from flask import Flask, jsonify
from flask_migrate import Migrate
from flask_sqlalchemy import SQLAlchemy
from flask_jwt_extended import JWTManager


db = SQLAlchemy()
migrate = Migrate()
jwt = JWTManager()


def register_extensions(app: Flask) -> None:
    from pear_admin import UserORM

    db.init_app(app)
    migrate.init_app(app, db)
    jwt.init_app(app)

    @jwt.user_lookup_loader
    def user_lookup_callback(_jwt_header, jwt_data):
        identity = jwt_data["sub"]
        return UserORM.query.filter_by(id=identity).one_or_none()

    @jwt.user_identity_loader
    def user_identity_lookup(user):
        return user.id

    @jwt.expired_token_loader
    def my_expired_token_callback(jwt_header, jwt_payload):
        return (
            jsonify(
                meta={
                    "status": "fail",
                    "message": "token 已失效",
                }
            ),
            401,
        )

```

### 登录与退出逻辑

```python
# -*- coding: utf-8 -*-
from flask import request, make_response, jsonify
from flask_jwt_extended import (
    create_access_token,
    jwt_required,
    set_access_cookies,
    unset_access_cookies,
)
from pear_admin.models import UserORM


def login_api():
    username = request.json.get("username")
    password = request.json.get("password")

    user: UserORM = UserORM.query.filter(UserORM.username == username).one_or_none()
    if not user:
        return {
            "meta": {
                "status": "fail",
                "message": "没有查询到此用户",
            }
        }, 401
    if not user.check_password(password):
        return {
            "meta": {
                "status": "fail",
                "message": "用户密码错误",
            }
        }, 401

    access_token = create_access_token(identity=user)
    response = make_response(
        {
            "result": {"access_token": access_token},
            "meta": {
                "status": "success",
                "message": "用户登录成功",
            },
        }
    )
    response.set_cookie("is_login", "true")
    return response


@jwt_required()
def logout_api():
    response = jsonify(
        {
            "meta": {
                "status": "success",
                "message": "用户退出成功",
            },
        }
    )
    response.set_cookie("is_login", "")
    return response

```



浏览器默认的请求不会携带token，想要实现登录拦截就必须权限校验，为了兼容默认的请求，所以通过 cookie 中也预留了一串 `is_login` 记录用户是否登录了 。
